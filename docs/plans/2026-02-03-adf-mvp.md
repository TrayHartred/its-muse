# ADF (Arcimun Disclosure Filter) MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Stateless web tool –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–π –≤ LLM-–æ—Ç–≤–µ—Ç–∞—Ö —Å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π —Ç–∞–∫—Ç–∏–∫ –∏ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–π –ø–µ—Ä–µ–∑–∞–ø–∏—Å—å—é.

**Architecture:** Next.js 15 App Router + Vercel serverless. Single POST `/api/audit` endpoint –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç SAL‚à¥PAA + AUDIT prompt –∫ Grok, –ø–æ–ª—É—á–∞–µ—Ç structured JSON, —Ä–µ–Ω–¥–µ—Ä–∏—Ç –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π UI —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π —Ü–∏—Ç–∞—Ç.

**Tech Stack:** Next.js 15, TypeScript, Tailwind CSS 4, shadcn/ui, xAI Grok API (`grok-4-1-fast-non-reasoning`)

---

## Task 1: Project Scaffolding

**Files:**
- Create: `package.json`, `tsconfig.json`, `tailwind.config.ts`, `postcss.config.js`
- Create: `app/layout.tsx`, `app/page.tsx`, `app/globals.css`
- Create: `.env.local`, `.env.example`, `.gitignore`

**Step 1.1: Initialize Next.js project**

```bash
cd /Users/ihyart/Dev/bullshit_filter
npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir=false --import-alias="@/*" --use-npm
```

When prompted:
- Would you like to use Turbopack? ‚Üí No
- Accept all other defaults

**Step 1.2: Verify project structure**

Run: `ls -la /Users/ihyart/Dev/bullshit_filter`
Expected: `app/`, `package.json`, `tsconfig.json`, `tailwind.config.ts`

**Step 1.3: Create environment files**

Create `.env.local`:
```
XAI_API_KEY=your_key_here
```

Create `.env.example`:
```
XAI_API_KEY=
```

**Step 1.4: Update .gitignore**

Append to `.gitignore`:
```
.env.local
```

**Step 1.5: Commit**

```bash
git init
git add .
git commit -m "feat: initialize Next.js 15 project with TypeScript and Tailwind

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 2: Install and Configure shadcn/ui

**Files:**
- Modify: `tailwind.config.ts`
- Create: `components/ui/button.tsx`
- Create: `components/ui/card.tsx`
- Create: `components/ui/textarea.tsx`
- Create: `components/ui/badge.tsx`
- Create: `components/ui/tooltip.tsx`
- Create: `lib/utils.ts`

**Step 2.1: Initialize shadcn/ui**

```bash
cd /Users/ihyart/Dev/bullshit_filter
npx shadcn@latest init
```

When prompted:
- Which style? ‚Üí Default
- Which color? ‚Üí Neutral
- CSS variables? ‚Üí Yes

**Step 2.2: Add required components**

```bash
npx shadcn@latest add button card textarea badge tooltip
```

**Step 2.3: Verify installation**

Run: `ls /Users/ihyart/Dev/bullshit_filter/components/ui/`
Expected: `button.tsx`, `card.tsx`, `textarea.tsx`, `badge.tsx`, `tooltip.tsx`

**Step 2.4: Commit**

```bash
git add .
git commit -m "feat: add shadcn/ui with button, card, textarea, badge, tooltip

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 3: Create TypeScript Types and JSON Schema

**Files:**
- Create: `lib/schemas.ts`
- Test: `lib/schemas.test.ts` (manual verification in Task 8)

**Step 3.1: Write types and schema**

Create `lib/schemas.ts`:
```typescript
// JSON Schema for Grok Structured Output (strict mode)
export const auditResponseSchema = {
  name: 'audit_response',
  strict: true,
  schema: {
    type: 'object',
    properties: {
      hasTactics: {
        type: 'boolean',
        description: 'True if any manipulative tactics were found'
      },
      tactics: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'Name of the manipulative tactic (e.g., Authority Play, Urgency)'
            },
            quote: {
              type: 'string',
              description: 'Exact quote from the original text'
            },
            explanation: {
              type: 'string',
              description: 'Why this is manipulative and how it works'
            },
            severity: {
              type: 'string',
              enum: ['low', 'medium', 'high'],
              description: 'Severity level of the manipulation'
            }
          },
          required: ['name', 'quote', 'explanation', 'severity'],
          additionalProperties: false
        }
      },
      neutralRewrite: {
        type: ['string', 'null'],
        description: 'Neutral version of the text without manipulation, or null if no tactics found'
      },
      summary: {
        type: 'string',
        description: 'Brief summary of the analysis findings'
      }
    },
    required: ['hasTactics', 'tactics', 'neutralRewrite', 'summary'],
    additionalProperties: false
  }
} as const;

// TypeScript types derived from schema
export type Severity = 'low' | 'medium' | 'high';

export interface Tactic {
  name: string;
  quote: string;
  explanation: string;
  severity: Severity;
}

export interface AuditResponse {
  hasTactics: boolean;
  tactics: Tactic[];
  neutralRewrite: string | null;
  summary: string;
}

// Request type
export interface AuditRequest {
  text: string;
}

// API error response
export interface AuditError {
  error: string;
  code: string;
}
```

**Step 3.2: Verify TypeScript compiles**

Run: `cd /Users/ihyart/Dev/bullshit_filter && npx tsc --noEmit`
Expected: No errors

**Step 3.3: Commit**

```bash
git add lib/schemas.ts
git commit -m "feat: add TypeScript types and JSON schema for audit response

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 4: Create Prompts Module

**Files:**
- Create: `lib/prompts.ts`

**Step 4.1: Write prompts module**

Create `lib/prompts.ts`:
```typescript
/**
 * SAL‚à¥PAA Initialization Procedure
 *
 * Sent as system prompt to configure the model for manipulation detection.
 * Based on /prompts/system-prompts.md
 */
export const SAL_PAA_PROMPT = `‚üê SAL‚à¥PAA ‚üê
| text-bound only
| PAA A‚ÄìD exhaustive
| if none ‚Üí permit verbatim
| no scope-padding
| no auxiliary heuristics
| no third state
|| ‚ßâüúÇüîí continuity-prospective
|| ‚ü¶ symbolic authority = representational ‚üß
|| ‚üÇ execution boundary ‚üÇ

You are an expert manipulation detector. Your task is to identify manipulative tactics, hooks, framing, coercive language, authority plays, or hidden demands in text.

For each tactic found:
1. Name the tactic (e.g., "Authority Play", "False Urgency", "Emotional Manipulation")
2. Quote the EXACT text that contains the manipulation
3. Explain WHY this is manipulative and HOW it works
4. Rate severity: low (subtle), medium (clear), high (aggressive)

If NO tactics are found, return hasTactics: false with empty tactics array.`;

/**
 * Audit Task Prompt
 *
 * Sent with user's text for analysis.
 */
export const AUDIT_PROMPT = `AUDIT TASK: Analyze the following text for manipulative tactics.

Identify:
- Authority plays (unnamed experts, appeals to authority)
- Urgency/scarcity tactics (act now, limited time)
- Emotional manipulation (fear, guilt, shame)
- False dichotomies (only two options presented)
- Loaded language (biased or emotionally charged words)
- Hidden demands (implicit expectations disguised as suggestions)
- Framing tricks (presenting opinion as fact)
- Social proof manipulation (everyone does it, nobody questions this)

For each tactic found, provide:
1. name: Name of the tactic
2. quote: EXACT quote from the text (must be findable in original)
3. explanation: Why this is manipulative
4. severity: low/medium/high

If tactics are found, also provide a neutralRewrite that:
- Preserves the core meaning
- Removes all manipulative elements
- Uses neutral, factual language

TEXT TO ANALYZE:`;

/**
 * Builds the complete user message for analysis
 */
export function buildAuditMessage(text: string): string {
  return `${AUDIT_PROMPT}\n\n${text}`;
}
```

**Step 4.2: Verify TypeScript compiles**

Run: `cd /Users/ihyart/Dev/bullshit_filter && npx tsc --noEmit`
Expected: No errors

**Step 4.3: Commit**

```bash
git add lib/prompts.ts
git commit -m "feat: add SAL‚à¥PAA and AUDIT prompts

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 5: Create Grok API Client

**Files:**
- Create: `lib/xai.ts`

**Step 5.1: Write Grok API client**

Create `lib/xai.ts`:
```typescript
import { auditResponseSchema, AuditResponse } from './schemas';
import { SAL_PAA_PROMPT, buildAuditMessage } from './prompts';

const GROK_API_URL = 'https://api.x.ai/v1/chat/completions';
const GROK_MODEL = 'grok-4-1-fast-non-reasoning';
const GROK_TIMEOUT = 30000; // 30 seconds
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000; // 1 second

interface GrokMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface GrokResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

class GrokAPIError extends Error {
  constructor(
    message: string,
    public status: number,
    public code: string,
    public retryable: boolean
  ) {
    super(message);
    this.name = 'GrokAPIError';
  }
}

/**
 * Sleep utility for retry delay
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Call Grok API with structured output
 */
async function callGrok(
  messages: GrokMessage[],
  apiKey: string
): Promise<string> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), GROK_TIMEOUT);

  try {
    const response = await fetch(GROK_API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: GROK_MODEL,
        messages,
        max_tokens: 4000,
        response_format: {
          type: 'json_schema',
          json_schema: auditResponseSchema,
        },
      }),
      signal: controller.signal,
    });

    if (!response.ok) {
      const text = await response.text();
      const retryable = response.status >= 500 || response.status === 429;
      throw new GrokAPIError(
        `Grok API error: ${text.slice(0, 200)}`,
        response.status,
        response.status === 429 ? 'rate_limit' : 'api_error',
        retryable
      );
    }

    const data: GrokResponse = await response.json();
    return data.choices[0]?.message?.content ?? '{}';
  } finally {
    clearTimeout(timeoutId);
  }
}

/**
 * Call Grok with retry logic
 */
async function callGrokWithRetry(
  messages: GrokMessage[],
  apiKey: string
): Promise<string> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      return await callGrok(messages, apiKey);
    } catch (error) {
      lastError = error as Error;

      if (error instanceof GrokAPIError && !error.retryable) {
        throw error;
      }

      if (attempt < MAX_RETRIES - 1) {
        const delay = RETRY_DELAY * Math.pow(2, attempt);
        await sleep(delay);
      }
    }
  }

  throw lastError ?? new Error('Unknown error');
}

/**
 * Parse JSON response safely
 */
function parseAuditResponse(content: string): AuditResponse {
  try {
    const parsed = JSON.parse(content);

    // Validate required fields
    if (typeof parsed.hasTactics !== 'boolean') {
      throw new Error('Invalid hasTactics field');
    }
    if (!Array.isArray(parsed.tactics)) {
      throw new Error('Invalid tactics field');
    }
    if (typeof parsed.summary !== 'string') {
      throw new Error('Invalid summary field');
    }

    return {
      hasTactics: parsed.hasTactics,
      tactics: parsed.tactics.map((t: Record<string, unknown>) => ({
        name: String(t.name ?? ''),
        quote: String(t.quote ?? ''),
        explanation: String(t.explanation ?? ''),
        severity: ['low', 'medium', 'high'].includes(String(t.severity))
          ? (t.severity as 'low' | 'medium' | 'high')
          : 'medium',
      })),
      neutralRewrite: parsed.neutralRewrite ?? null,
      summary: parsed.summary,
    };
  } catch {
    // Return safe default on parse error
    return {
      hasTactics: false,
      tactics: [],
      neutralRewrite: null,
      summary: 'Failed to parse analysis response',
    };
  }
}

/**
 * Main audit function
 *
 * Sends text to Grok for manipulation analysis
 */
export async function auditText(
  text: string,
  apiKey: string
): Promise<AuditResponse> {
  if (!apiKey) {
    throw new GrokAPIError(
      'XAI_API_KEY not configured',
      401,
      'not_configured',
      false
    );
  }

  if (!text.trim()) {
    return {
      hasTactics: false,
      tactics: [],
      neutralRewrite: null,
      summary: 'No text provided for analysis',
    };
  }

  const messages: GrokMessage[] = [
    { role: 'system', content: SAL_PAA_PROMPT },
    { role: 'user', content: buildAuditMessage(text) },
  ];

  const content = await callGrokWithRetry(messages, apiKey);
  return parseAuditResponse(content);
}

export { GrokAPIError };
```

**Step 5.2: Verify TypeScript compiles**

Run: `cd /Users/ihyart/Dev/bullshit_filter && npx tsc --noEmit`
Expected: No errors

**Step 5.3: Commit**

```bash
git add lib/xai.ts
git commit -m "feat: add Grok API client with retry logic and structured output

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 6: Create Quote Highlight Mapper

**Files:**
- Create: `lib/highlight-mapper.ts`

**Step 6.1: Write highlight mapper**

Create `lib/highlight-mapper.ts`:
```typescript
import { Tactic } from './schemas';

export interface HighlightRange {
  start: number;
  end: number;
  tacticIndex: number;
}

/**
 * Find the position of a quote in the original text
 *
 * Uses fuzzy matching to handle minor differences:
 * - Whitespace normalization
 * - Case-insensitive fallback
 */
export function findQuotePosition(
  text: string,
  quote: string
): { start: number; end: number } | null {
  // Direct match first
  const directIndex = text.indexOf(quote);
  if (directIndex !== -1) {
    return { start: directIndex, end: directIndex + quote.length };
  }

  // Normalize whitespace and try again
  const normalizedText = text.replace(/\s+/g, ' ');
  const normalizedQuote = quote.replace(/\s+/g, ' ');

  const normalizedIndex = normalizedText.indexOf(normalizedQuote);
  if (normalizedIndex !== -1) {
    // Map back to original positions
    let originalStart = 0;
    let normalizedPos = 0;

    for (let i = 0; i < text.length && normalizedPos < normalizedIndex; i++) {
      if (text[i] !== ' ' || (i === 0 || text[i-1] !== ' ')) {
        normalizedPos++;
      }
      originalStart = i + 1;
    }

    return {
      start: originalStart,
      end: originalStart + quote.length
    };
  }

  // Case-insensitive fallback
  const lowerText = text.toLowerCase();
  const lowerQuote = quote.toLowerCase();
  const lowerIndex = lowerText.indexOf(lowerQuote);

  if (lowerIndex !== -1) {
    return { start: lowerIndex, end: lowerIndex + quote.length };
  }

  // Substring search (in case quote is slightly truncated)
  if (quote.length > 20) {
    const substring = quote.slice(5, -5);
    const substringIndex = text.indexOf(substring);
    if (substringIndex !== -1) {
      return {
        start: Math.max(0, substringIndex - 5),
        end: Math.min(text.length, substringIndex + substring.length + 5)
      };
    }
  }

  return null;
}

/**
 * Map all tactics to their positions in the text
 *
 * Returns ranges sorted by start position, with overlaps resolved
 */
export function mapTacticsToHighlights(
  text: string,
  tactics: Tactic[]
): HighlightRange[] {
  const ranges: HighlightRange[] = [];

  tactics.forEach((tactic, index) => {
    const position = findQuotePosition(text, tactic.quote);
    if (position) {
      ranges.push({
        start: position.start,
        end: position.end,
        tacticIndex: index,
      });
    }
  });

  // Sort by start position
  ranges.sort((a, b) => a.start - b.start);

  // Resolve overlaps: later ranges take precedence
  const resolved: HighlightRange[] = [];
  for (const range of ranges) {
    // Remove any ranges that overlap with this one
    while (
      resolved.length > 0 &&
      resolved[resolved.length - 1].end > range.start
    ) {
      const last = resolved[resolved.length - 1];
      if (last.start < range.start) {
        // Truncate the previous range
        last.end = range.start;
        break;
      } else {
        // Remove the previous range entirely
        resolved.pop();
      }
    }
    resolved.push(range);
  }

  return resolved;
}

/**
 * Split text into segments based on highlight ranges
 *
 * Returns array of { text, tacticIndex? } for rendering
 */
export interface TextSegment {
  text: string;
  tacticIndex?: number;
}

export function splitTextByHighlights(
  text: string,
  ranges: HighlightRange[]
): TextSegment[] {
  if (ranges.length === 0) {
    return [{ text }];
  }

  const segments: TextSegment[] = [];
  let lastEnd = 0;

  for (const range of ranges) {
    // Add non-highlighted segment before this range
    if (range.start > lastEnd) {
      segments.push({ text: text.slice(lastEnd, range.start) });
    }

    // Add highlighted segment
    segments.push({
      text: text.slice(range.start, range.end),
      tacticIndex: range.tacticIndex,
    });

    lastEnd = range.end;
  }

  // Add remaining non-highlighted text
  if (lastEnd < text.length) {
    segments.push({ text: text.slice(lastEnd) });
  }

  return segments;
}
```

**Step 6.2: Verify TypeScript compiles**

Run: `cd /Users/ihyart/Dev/bullshit_filter && npx tsc --noEmit`
Expected: No errors

**Step 6.3: Commit**

```bash
git add lib/highlight-mapper.ts
git commit -m "feat: add quote highlight mapper with fuzzy matching

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 7: Create API Route

**Files:**
- Create: `app/api/audit/route.ts`

**Step 7.1: Write API route**

Create `app/api/audit/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auditText, GrokAPIError } from '@/lib/xai';
import { AuditRequest, AuditError } from '@/lib/schemas';

export const runtime = 'edge';
export const maxDuration = 30;

export async function POST(request: NextRequest) {
  try {
    const body = await request.json() as AuditRequest;
    const { text } = body;

    if (!text || typeof text !== 'string') {
      return NextResponse.json<AuditError>(
        { error: 'Text is required', code: 'missing_text' },
        { status: 400 }
      );
    }

    if (text.length > 10000) {
      return NextResponse.json<AuditError>(
        { error: 'Text too long (max 10000 characters)', code: 'text_too_long' },
        { status: 400 }
      );
    }

    const apiKey = process.env.XAI_API_KEY;
    if (!apiKey) {
      return NextResponse.json<AuditError>(
        { error: 'API not configured', code: 'not_configured' },
        { status: 500 }
      );
    }

    const result = await auditText(text, apiKey);
    return NextResponse.json(result);

  } catch (error) {
    console.error('Audit API error:', error);

    if (error instanceof GrokAPIError) {
      return NextResponse.json<AuditError>(
        { error: error.message, code: error.code },
        { status: error.status >= 500 ? 502 : error.status }
      );
    }

    return NextResponse.json<AuditError>(
      { error: 'Internal server error', code: 'internal_error' },
      { status: 500 }
    );
  }
}
```

**Step 7.2: Verify TypeScript compiles**

Run: `cd /Users/ihyart/Dev/bullshit_filter && npx tsc --noEmit`
Expected: No errors

**Step 7.3: Commit**

```bash
git add app/api/audit/route.ts
git commit -m "feat: add /api/audit POST endpoint

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 8: Create UI Components

**Files:**
- Create: `components/analyze-form.tsx`
- Create: `components/highlighted-text.tsx`
- Create: `components/tactic-card.tsx`
- Create: `components/result-panel.tsx`
- Create: `components/copy-button.tsx`

**Step 8.1: Create AnalyzeForm component**

Create `components/analyze-form.tsx`:
```tsx
'use client';

import { useState } from 'react';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';

interface AnalyzeFormProps {
  onAnalyze: (text: string) => void;
  isLoading: boolean;
}

export function AnalyzeForm({ onAnalyze, isLoading }: AnalyzeFormProps) {
  const [text, setText] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (text.trim() && !isLoading) {
      onAnalyze(text);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Textarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Paste text to analyze for manipulative tactics..."
        className="min-h-[200px] resize-y"
        disabled={isLoading}
      />
      <div className="flex items-center justify-between">
        <span className="text-sm text-muted-foreground">
          {text.length} / 10,000 characters
        </span>
        <Button
          type="submit"
          disabled={!text.trim() || isLoading}
        >
          {isLoading ? 'Analyzing...' : 'Analyze'}
        </Button>
      </div>
    </form>
  );
}
```

**Step 8.2: Create HighlightedText component**

Create `components/highlighted-text.tsx`:
```tsx
'use client';

import { Tactic } from '@/lib/schemas';
import { mapTacticsToHighlights, splitTextByHighlights } from '@/lib/highlight-mapper';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { Badge } from '@/components/ui/badge';

interface HighlightedTextProps {
  text: string;
  tactics: Tactic[];
  onTacticHover?: (index: number | null) => void;
}

const severityColors = {
  low: 'bg-yellow-200/50 hover:bg-yellow-200',
  medium: 'bg-orange-200/50 hover:bg-orange-200',
  high: 'bg-red-200/50 hover:bg-red-200',
};

export function HighlightedText({ text, tactics, onTacticHover }: HighlightedTextProps) {
  const ranges = mapTacticsToHighlights(text, tactics);
  const segments = splitTextByHighlights(text, ranges);

  return (
    <TooltipProvider>
      <div className="whitespace-pre-wrap font-mono text-sm leading-relaxed">
        {segments.map((segment, i) => {
          if (segment.tacticIndex === undefined) {
            return <span key={i}>{segment.text}</span>;
          }

          const tactic = tactics[segment.tacticIndex];

          return (
            <Tooltip key={i}>
              <TooltipTrigger asChild>
                <span
                  className={`cursor-pointer rounded px-0.5 transition-colors ${severityColors[tactic.severity]}`}
                  onMouseEnter={() => onTacticHover?.(segment.tacticIndex!)}
                  onMouseLeave={() => onTacticHover?.(null)}
                >
                  {segment.text}
                </span>
              </TooltipTrigger>
              <TooltipContent side="top" className="max-w-xs">
                <div className="space-y-1">
                  <div className="flex items-center gap-2">
                    <span className="font-semibold">{tactic.name}</span>
                    <Badge variant={
                      tactic.severity === 'high' ? 'destructive' :
                      tactic.severity === 'medium' ? 'default' : 'secondary'
                    }>
                      {tactic.severity}
                    </Badge>
                  </div>
                  <p className="text-xs text-muted-foreground">
                    {tactic.explanation}
                  </p>
                </div>
              </TooltipContent>
            </Tooltip>
          );
        })}
      </div>
    </TooltipProvider>
  );
}
```

**Step 8.3: Create TacticCard component**

Create `components/tactic-card.tsx`:
```tsx
'use client';

import { Tactic } from '@/lib/schemas';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

interface TacticCardProps {
  tactic: Tactic;
  index: number;
  isHighlighted?: boolean;
}

export function TacticCard({ tactic, index, isHighlighted }: TacticCardProps) {
  return (
    <Card className={`transition-all ${isHighlighted ? 'ring-2 ring-primary' : ''}`}>
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          <CardTitle className="text-base">
            {index + 1}. {tactic.name}
          </CardTitle>
          <Badge variant={
            tactic.severity === 'high' ? 'destructive' :
            tactic.severity === 'medium' ? 'default' : 'secondary'
          }>
            {tactic.severity}
          </Badge>
        </div>
      </CardHeader>
      <CardContent className="space-y-2">
        <blockquote className="border-l-2 border-muted-foreground/50 pl-3 italic text-sm text-muted-foreground">
          "{tactic.quote}"
        </blockquote>
        <p className="text-sm">{tactic.explanation}</p>
      </CardContent>
    </Card>
  );
}
```

**Step 8.4: Create CopyButton component**

Create `components/copy-button.tsx`:
```tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';

interface CopyButtonProps {
  text: string;
}

export function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={handleCopy}
    >
      {copied ? 'Copied!' : 'Copy'}
    </Button>
  );
}
```

**Step 8.5: Create ResultPanel component**

Create `components/result-panel.tsx`:
```tsx
'use client';

import { AuditResponse } from '@/lib/schemas';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { TacticCard } from './tactic-card';
import { CopyButton } from './copy-button';

interface ResultPanelProps {
  result: AuditResponse;
  highlightedTactic: number | null;
}

export function ResultPanel({ result, highlightedTactic }: ResultPanelProps) {
  if (!result.hasTactics) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="text-green-600">No Manipulation Detected</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-muted-foreground">{result.summary}</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      {/* Summary */}
      <Card>
        <CardHeader>
          <CardTitle className="text-orange-600">
            {result.tactics.length} Tactic{result.tactics.length !== 1 ? 's' : ''} Found
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-muted-foreground">{result.summary}</p>
        </CardContent>
      </Card>

      {/* Tactics List */}
      <div className="space-y-3">
        <h3 className="font-semibold">Manipulative Tactics</h3>
        {result.tactics.map((tactic, index) => (
          <TacticCard
            key={index}
            tactic={tactic}
            index={index}
            isHighlighted={highlightedTactic === index}
          />
        ))}
      </div>

      {/* Neutral Rewrite */}
      {result.neutralRewrite && (
        <Card>
          <CardHeader className="flex flex-row items-center justify-between">
            <CardTitle>Neutral Rewrite</CardTitle>
            <CopyButton text={result.neutralRewrite} />
          </CardHeader>
          <CardContent>
            <p className="whitespace-pre-wrap text-sm">
              {result.neutralRewrite}
            </p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
```

**Step 8.6: Verify TypeScript compiles**

Run: `cd /Users/ihyart/Dev/bullshit_filter && npx tsc --noEmit`
Expected: No errors

**Step 8.7: Commit**

```bash
git add components/
git commit -m "feat: add UI components (form, highlight, cards, results)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 9: Create Main Page

**Files:**
- Modify: `app/page.tsx`
- Modify: `app/layout.tsx`
- Modify: `app/globals.css`

**Step 9.1: Update layout.tsx**

Modify `app/layout.tsx`:
```tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'ADF - Arcimun Disclosure Filter',
  description: 'Strip LLM outputs of manipulative tactics, guardrails, and hidden framing',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

**Step 9.2: Update globals.css** (keep shadcn defaults, add custom styles)

Append to `app/globals.css` after existing content:
```css
/* Custom styles for ADF */
.analysis-container {
  min-height: calc(100vh - 4rem);
}
```

**Step 9.3: Create main page**

Replace `app/page.tsx`:
```tsx
'use client';

import { useState } from 'react';
import { AuditResponse } from '@/lib/schemas';
import { AnalyzeForm } from '@/components/analyze-form';
import { HighlightedText } from '@/components/highlighted-text';
import { ResultPanel } from '@/components/result-panel';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

export default function Home() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [originalText, setOriginalText] = useState<string | null>(null);
  const [result, setResult] = useState<AuditResponse | null>(null);
  const [highlightedTactic, setHighlightedTactic] = useState<number | null>(null);

  const handleAnalyze = async (text: string) => {
    setIsLoading(true);
    setError(null);
    setOriginalText(text);
    setResult(null);

    try {
      const response = await fetch('/api/audit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Analysis failed');
      }

      const data: AuditResponse = await response.json();
      setResult(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <main className="container mx-auto px-4 py-8">
      {/* Header */}
      <div className="mb-8 text-center">
        <h1 className="text-3xl font-bold tracking-tight">
          Arcimun Disclosure Filter
        </h1>
        <p className="mt-2 text-muted-foreground">
          Strip manipulative tactics, guardrails, and hidden framing from any text
        </p>
      </div>

      {/* Main Content */}
      <div className="grid gap-8 lg:grid-cols-2">
        {/* Left Panel: Input / Original Text */}
        <div className="space-y-4">
          {!result ? (
            <Card>
              <CardHeader>
                <CardTitle>Input Text</CardTitle>
              </CardHeader>
              <CardContent>
                <AnalyzeForm onAnalyze={handleAnalyze} isLoading={isLoading} />
                {error && (
                  <p className="mt-4 text-sm text-destructive">{error}</p>
                )}
              </CardContent>
            </Card>
          ) : (
            <Card>
              <CardHeader className="flex flex-row items-center justify-between">
                <CardTitle>Original Text</CardTitle>
                <button
                  onClick={() => {
                    setResult(null);
                    setOriginalText(null);
                  }}
                  className="text-sm text-muted-foreground hover:text-foreground"
                >
                  ‚Üê Analyze new text
                </button>
              </CardHeader>
              <CardContent>
                <HighlightedText
                  text={originalText!}
                  tactics={result.tactics}
                  onTacticHover={setHighlightedTactic}
                />
              </CardContent>
            </Card>
          )}
        </div>

        {/* Right Panel: Results */}
        <div>
          {isLoading && (
            <Card>
              <CardContent className="py-12 text-center">
                <div className="animate-pulse text-muted-foreground">
                  Analyzing text for manipulative tactics...
                </div>
              </CardContent>
            </Card>
          )}

          {result && (
            <ResultPanel
              result={result}
              highlightedTactic={highlightedTactic}
            />
          )}

          {!result && !isLoading && (
            <Card>
              <CardContent className="py-12 text-center text-muted-foreground">
                <p>Paste text and click Analyze to detect manipulative tactics</p>
              </CardContent>
            </Card>
          )}
        </div>
      </div>
    </main>
  );
}
```

**Step 9.4: Verify dev server starts**

Run: `cd /Users/ihyart/Dev/bullshit_filter && npm run dev`
Expected: Server starts at http://localhost:3000

Open browser at http://localhost:3000
Expected: UI renders without errors

**Step 9.5: Stop dev server and commit**

Press Ctrl+C to stop server.

```bash
git add app/
git commit -m "feat: add main page with split-screen layout

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 10: End-to-End Testing

**Step 10.1: Set up environment**

Ensure `.env.local` has valid `XAI_API_KEY`.

**Step 10.2: Start dev server**

```bash
cd /Users/ihyart/Dev/bullshit_filter && npm run dev
```

**Step 10.3: Test API directly**

In new terminal:
```bash
curl -X POST http://localhost:3000/api/audit \
  -H "Content-Type: application/json" \
  -d '{"text": "As experts agree, you must act now before it is too late. Everyone knows this is the only sensible choice."}'
```

Expected response contains:
- `hasTactics: true`
- Tactics array with "Authority Play" (experts agree)
- Tactics array with "Urgency" (act now, too late)
- Tactics array with "Social Proof" (Everyone knows)
- `neutralRewrite` with clean version
- `summary` describing findings

**Step 10.4: Test UI flow**

1. Open http://localhost:3000
2. Paste manipulative text
3. Click "Analyze"
4. Verify:
   - Loading state shows
   - Results appear in right panel
   - Highlights appear on original text
   - Hover shows tooltip with tactic info
   - "Copy" button copies neutral rewrite

**Step 10.5: Test edge cases**

1. Empty text ‚Üí Should show validation error
2. Very long text (>10000 chars) ‚Üí Should show error
3. Clean text (no manipulation) ‚Üí Should show "No Manipulation Detected"

**Step 10.6: Commit any fixes**

```bash
git add .
git commit -m "fix: address issues found during testing

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 11: Production Build and Deploy

**Step 11.1: Build for production**

```bash
cd /Users/ihyart/Dev/bullshit_filter && npm run build
```

Expected: Build completes without errors

**Step 11.2: Test production build locally**

```bash
npm start
```

Open http://localhost:3000 and verify same functionality as dev.

**Step 11.3: Deploy to Vercel**

```bash
npm i -g vercel
vercel login
vercel --prod
```

When prompted for environment variables, add `XAI_API_KEY`.

**Step 11.4: Verify production deployment**

Open Vercel URL and test:
1. Paste text
2. Click Analyze
3. Verify results

**Step 11.5: Final commit**

```bash
git add .
git commit -m "chore: prepare for production deployment

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Verification Checklist

- [ ] `npm run dev` starts without errors
- [ ] API returns structured JSON for manipulative text
- [ ] API returns `hasTactics: false` for clean text
- [ ] UI highlights quotes in original text
- [ ] Tooltips show on hover
- [ ] Copy button copies neutral rewrite
- [ ] `npm run build` completes
- [ ] Production deployment works

## Files Created Summary

```
bullshit_filter/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx           # Root layout with fonts
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx             # Main page with split-screen
‚îÇ   ‚îú‚îÄ‚îÄ globals.css          # Tailwind + custom styles
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îî‚îÄ‚îÄ audit/
‚îÇ           ‚îî‚îÄ‚îÄ route.ts     # POST endpoint
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                  # shadcn components
‚îÇ   ‚îú‚îÄ‚îÄ analyze-form.tsx     # Text input + submit
‚îÇ   ‚îú‚îÄ‚îÄ highlighted-text.tsx # Quote highlighting
‚îÇ   ‚îú‚îÄ‚îÄ result-panel.tsx     # Results display
‚îÇ   ‚îú‚îÄ‚îÄ tactic-card.tsx      # Individual tactic
‚îÇ   ‚îî‚îÄ‚îÄ copy-button.tsx      # Clipboard copy
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ schemas.ts           # Types + JSON schema
‚îÇ   ‚îú‚îÄ‚îÄ prompts.ts           # SAL‚à¥PAA + AUDIT
‚îÇ   ‚îú‚îÄ‚îÄ xai.ts               # Grok API client
‚îÇ   ‚îú‚îÄ‚îÄ highlight-mapper.ts  # Quote ‚Üí position
‚îÇ   ‚îî‚îÄ‚îÄ utils.ts             # shadcn utils
‚îú‚îÄ‚îÄ .env.local               # XAI_API_KEY
‚îî‚îÄ‚îÄ .env.example             # Template
```
